To ensure your project documentation is accurate and reflects the professional standards required for your Bachelor of Science in Computer Engineering, here is a formal summary of the Mutual TLS (mTLS) Security Setup you have just completed on your Raspberry Pi 5.
Documentation: Secure Communication Setup via MQTT over TLS

Project: Pipeline Monitoring Systems Security node with AI Anomaly Detection

Hardware: Raspberry Pi 5 (8GB RAM, ARM 64-bit)

Security Protocol: Mutual Transport Layer Security (mTLS)
1. Overview

To protect the integrity and confidentiality of the industrial sensor data (flow rate, temperature, pressure, and current) transmitted from the ESP32 to the Raspberry Pi 5, we implemented Mutual TLS (mTLS). Unlike standard TLS where only the server is verified, mTLS requires both the Raspberry Pi (Server) and the ESP32/Laptop (Clients) to provide valid certificates signed by a private Certificate Authority (CA).
2. Security Architecture

We utilized a Public Key Infrastructure (PKI) model. By creating our own private CA, we ensure that only devices we manually "sign" can join the pipeline network, preventing unauthorized devices from injecting malicious data or spoofing alerts.
3. Generated Cryptographic Assets

The following files were generated on the Raspberry Pi 5 using OpenSSL:
File Name	Type	Purpose	Location
ca.crt	Root Certificate	The "Master" certificate used by all devices to verify each other.	RPi, ESP32, Laptop
ca.key	Private Key	Used to sign new certificates. Must remain secret on the RPi.	RPi (Hidden)
server.crt	Identity Cert	Proves the Raspberry Pi is the legitimate broker.	RPi 5
server.key	Private Key	Encrypts the Pi’s side of the TLS handshake.	RPi 5
client.crt	Identity Cert	Proves the ESP32/Laptop are authorized users.	ESP32, Laptop
client.key	Private Key	Encrypts the Client's side of the TLS handshake.	ESP32, Laptop
4. Implementation Steps Completed

    Environment Preparation: Created a secure directory structure in the home folder and established a Python Virtual Environment (venv) to manage dependencies (NumPy, Scikit-learn, Pandas) for the AI detection engine.

    CA Generation: Created a 2048-bit RSA Private Key and a self-signed Root Certificate valid for 10 years.

    Server Identity: Generated a Certificate Signing Request (CSR) specifically for the Raspberry Pi 5’s IP address and signed it with the CA.

    Client Identity: Generated a generic client certificate/key pair to be shared by the ESP32 and the Node-RED SCADA dashboard.

    Permissions Hardening: Applied Linux filesystem permissions (chmod 600) to the private keys to ensure that only the Mosquitto service and the project owner can access them.

5. Technical Specifications

    Encryption Algorithm: RSA 2048-bit.

    Hashing Algorithm: SHA-256.

    Standard Port: 8883 (The industry standard for Secure MQTT).

    Authentication: Mutual (Certificate-based) + Username/Password (optional layer).

6. Next Implementation Phase

The system is now ready for:

    Broker Configuration: Applying these certificates to the mosquitto.conf file.

    Client Integration: Embedding the ca.crt, client.crt, and client.key into the ESP32 firmware and the Node-RED TLS configuration on the laptop.

    AI Inference: Loading the pre-trained LSTM/windowing model to begin processing the secure data stream.

Status: TLS Infrastructure [COMPLETED]
